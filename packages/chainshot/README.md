# @cloudwalk/chainshot

Chai plugin for Hardhat tests that records on-chain scenarios: every method call, emitted events, and token balances after each transaction. It creates machine-readable snapshots for regression testing and human-readable Markdown reports with Mermaid sequence diagrams.

- **Works with**: Mocha + Chai in Hardhat
- **Active on**: `hardhat` network (no-ops on others)

## Installation

```bash
npm i -D @cloudwalk/chainshot
# peer deps you likely already have in a Hardhat project
npm i -D @nomicfoundation/hardhat-ethers chai mocha hardhat
```

## Quick start

Enable the plugin via Mocha root hooks in your Hardhat config (Hardhat v2):

```ts
// hardhat.config.ts
import type { HardhatUserConfig } from "hardhat/config";
import { mochaHooks } from "@cloudwalk/chainshot";

const config: HardhatUserConfig = {
  mocha: {
    // Initializes Chainshot and registers helpers on Chai's expect
    rootHooks: mochaHooks(),
  },
};

export default config;
```

Optionally, you can pass a custom Hardhat runtime or configure the Jest-style snapshot plugin that Chainshot uses under the hood:

```ts
mochaHooks({
  // Provide a specific HRE if you need to customize it; otherwise it is auto-required
  // hre,
  // Configure mocha-chai-jest-snapshot (Jest-style snapshots placed next to tests)
  jestSnapshotPluginConfig: {
    // Any relevant Jest project config options
  },
});
```

Alternatively, use a Mocha hook file with Hardhat by adding this to `.mocharc.json`:

```json
{
  "require": ["hardhat/register", "@cloudwalk/chainshot/hook"],
  "timeout": 40000,
  "_": ["test/**/*.ts"]
}
```

Note: import the Chainshot hook after `hardhat/register` so the Hardhat Runtime Environment is available.

Write a scenario in a test by starting and ending it around the code that sends transactions:

```ts
import { expect } from "chai";

it("transfers tokens", async () => {
  await expect.startChainshot({
    name: "Happy path: transfer",
    accounts: {
      Alice: alice.address,
      Bob: bob.address,
    },
    contracts: {
      Token: token, // ethers BaseContract
      Vault: vault,
    },
    tokens: {
      Token: token,
    },
  });

  await token.connect(alice).transfer(bob.address, 100n);
  await vault.connect(bob).deposit(50n);

  await expect.stopChainshot();
});
```

That’s it. On `stopChainshot()` the plugin will:

- Restore the provider
- Process captured transactions
- Snapshot the scenario logs with `toMatchSnapshot()`
- Generate a human-friendly Markdown report (including a Mermaid sequence diagram)

## What gets captured

For each transaction submitted after `startChainshot` and before `stopChainshot`:

- **Method call**: contract, function name, and decoded arguments
- **Caller**: resolved to your friendly name (e.g., `Alice`)
- **Events**: all emitted events decoded per contract interfaces
  (excluding ERC20 `Transfer` from contracts listed in `tokens`; those
  are rendered as transfer arrows in the Mermaid diagram rather than as
  regular events)
- **Balances**: for every token in `tokens`, a balance table for all `accounts` and `contracts`

These records are aggregated into `scenario.logs` and compared against a snapshot for regression testing.

## Human-readable snapshots

In addition to the test snapshot, a Markdown report is created next to your test file in `__snapshots__humans__/YourTest.md` with:

- A nicely formatted scenario overview
- A **Mermaid sequence diagram** showing callers, contracts, and token transfers

Most editors (and GitHub) can render Mermaid diagrams directly. If not, copy the Mermaid block into any Mermaid previewer.

## API

```ts
function mochaHooks(options?: {
  hre?: HardhatRuntimeEnvironment;
  jestSnapshotPluginConfig?: Partial<
    import("@jest/types").Config.ProjectConfig
  >;
}): import("mocha").RootHookObject;
```

When initialized, the plugin registers two async helpers on Chai’s `expect`:

```ts
await expect.startChainshot(config: ScenarioConfig)
await expect.stopChainshot()
```

### ScenarioConfig

```ts
interface ScenarioConfig {
  name?: string; // optional scenario name; autogenerated from test titles if omitted
  accounts: Record<string, string>; // label -> address
  contracts: Record<string, BaseContract>; // label -> ethers contract (used for tx decoding)
  tokens: Record<string, BaseContract>; // label -> ERC20-like (uses decimals(), balanceOf())
}
```

Notes:

- Token contracts are configured separately from other `contracts` because their ERC20 `Transfer` events are treated specially: they are converted into token-movement arrows in the Mermaid diagram and are not shown as regular events. Tokens are also used to compute per-step balances.
- Provide every address that may receive or send tokens in `accounts` and `contracts` so balances include them.

## Important details

- **Hardhat-only behavior**: When `hre.network.name !== "hardhat"`, the helpers are installed as no-ops. On `hardhat`, they capture provider traffic by wrapping `provider.send`.
- **One scenario per test**: Each Mocha test should start and end at most one scenario. Missing `stopChainshot()` will fail the test with an assertion.
- **Snapshots**: Uses `mocha-chai-jest-snapshot` under the hood so Jest-style snapshots are written next to your tests. You can configure it via the optional parameter shown above.
- **TypeScript**: Types are published; import from `@cloudwalk/chainshot`.

## Troubleshooting

- Test fails with: `There are still running snapshot scenarios`
  - Ensure every `startChainshot` is paired with `stopChainshot` inside the same test.

- No arrows for token movements in the diagram
  - Only ERC20 `Transfer` events are converted into arrows. Ensure the token is included in `tokens` and emits standard `Transfer(from, to, amount)`.

- Balances look wrong
  - Balances are read using `balanceOf(address)` at each transaction’s block. Confirm the address labels in `accounts`/`contracts` map to the correct addresses.

## License

MIT
